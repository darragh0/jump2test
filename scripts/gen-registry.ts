/**
 * EXIT CODES:
 *   1 - wrong cwd
 *   2 - invalid stack name
 *   3 - stack file not found
 *   4 - failed to create registry directory
 *   5 - failed to write to registry files
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

if (!process.cwd().endsWith("jump2test")) {
  console.error(
    "\x1b[91merror:\x1b[0m this script must be run from the root of the project (\x1b[93mjump2test\x1b[0m)"
  );
  process.exit(1);
}

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const implDir = path.join(__dirname, "..", "src", "stack", "impl");
const registryDir = path.join(__dirname, "..", "src", "stack", "registry");
const registryConstPath = path.join(registryDir, "const.ts");
const registryIndexPath = path.join(registryDir, "index.ts");

// Get all dirs in impl/
const stackDirs = fs
  .readdirSync(implDir, { withFileTypes: true })
  .filter((dirent) => dirent.isDirectory())
  .map((dirent) => dirent.name);

// Find stack file in each directory (same name as dir)
const imports: string[] = [];
const stackNames: string[] = [];
const regex = /^[a-zA-Z0-9-]+$/;

for (const dir of stackDirs) {
  if (!regex.test(dir)) {
    console.error(`\x1b[91merror:\x1b[0m \x1b[93m${dir}\x1b[0m is not a valid stack name`);
    process.exit(2);
  }
  const file = path.join(implDir, dir, "index.ts");
  if (fs.existsSync(file)) {
    imports.push(`import ${dir} from "@impl/${dir}";`);
    stackNames.push(dir);
  } else {
    console.error(
      `\x1b[91merror:\x1b[0m \x1b[93mindex.ts\x1b[0m not found in \x1b[93m${implDir}/${dir}\x1b[0m`
    );
    process.exit(3);
  }
}

const registryConstTs = `\
// Auto-generated by \`scripts/gen-registry.ts\` (DO NOT EDIT)
// Refer to \`CONTRIBUTING.md\` for adding a new stack

// Auto-imported stacks
${imports.join("\n")}

const StackIdArr = [${stackNames.map((name) => `"${name}"`).join(", ")}] as const;
const ALL_STACKS = [${stackNames.join(", ")}] as const;

export { ALL_STACKS, StackIdArr };
`;

const registryIndexTs = `\
// Auto-generated by \`scripts/gen-registry.ts\` (DO NOT EDIT)
// Refer to \`CONTRIBUTING.md\` for adding a new stack

import { ALL_STACKS } from "@stack/registry/const";
import { trace } from "@common/logging";
import { StackId } from "@stack/types";
import { Stack } from "@stack/interface";

const stacks = new Map<StackId, Stack>();
let initialized = false;

function registerStack(stack: Stack): void {
  stacks.set(stack.id, stack);
  trace(\`Registered stack with ID: "\${stack.id}"\`);
}

function getStack(id: StackId): Stack | undefined {
  if (!initialized) initializeStacks();
  return stacks.get(id);
}

function getAllStacks(): Stack[] {
  if (!initialized) initializeStacks();
  return Array.from(stacks.values());
}

function initializeStacks(): void {
  if (initialized) return;
  ALL_STACKS.forEach(registerStack);
  initialized = true;
}

export { getAllStacks, getStack, registerStack };
`;

try {
  fs.mkdirSync(registryDir, { recursive: true });
} catch (error) {
  console.error(`\x1b[91merror:\x1b[0m failed to create directory \x1b[93m${registryDir}\x1b[0m`);
  process.exit(4);
}

for (const file of [
  [registryConstPath, registryConstTs],
  [registryIndexPath, registryIndexTs],
]) {
  try {
    fs.writeFileSync(file[0], file[1]);
  } catch (error) {
    console.error(
      `\x1b[91merror:\x1b[0m failed to write to \x1b[93msrc/stack/registry/${path.basename(file[0])}\x1b[0m`
    );
    process.exit(5);
  }
}

console.log(
  `\x1b[92msuccess:\x1b[0m generated \x1b[93msrc/stack/registry/index.ts\x1b[0m with \x1b[94m${stackNames.length}\x1b[0m stacks: \n  - ${stackNames.join("\n  - ")}\n`
);
